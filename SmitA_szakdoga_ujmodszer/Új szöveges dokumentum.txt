lidar ha kell lezer helyett
hatso kerekeknel motort kiszedni, csak hingejoint ha kell
megnezni a beepitett autokat

sjat autoszeru auto
utvonalkereso, ami alapjan az auto megy
utana meg ha kell akk akadalyok


chatgpt forditott
#include <stdio.h>
#include <limits.h>
#include <stdbool.h>

#define MAX 100
#define v 8

int queue[MAX];
int front = 0;
int rear = -1;

void add_edge(int adj[v][v], int src, int dest) {
    adj[src][dest] = 1;
    adj[dest][src] = 1;
}

bool BFS(int adj[v][v], int src, int dest, int v, int pred[], int dist[]) {
    int i, u;
    for (i = 0; i < v; i++) {
        dist[i] = INT_MAX;
        pred[i] = -1;
    }
    dist[src] = 0;
    pred[src] = -1;
    queue[++rear] = src;
    while (front <= rear) {
        u = queue[front++];
        for (i = 0; i < v; i++) {
            if (adj[u][i] == 1 && dist[i] == INT_MAX) {
                dist[i] = dist[u] + 1;
                pred[i] = u;
                queue[++rear] = i;
                if (i == dest)
                    return true;
            }
        }
    }
    return false;
}

void printShortestDistance(int adj[v][v], int s, int dest, int v) {
    int pred[v], dist[v];
    if (BFS(adj, s, dest, v, pred, dist) == false) {
        printf("Given source and destination are not connected\n");
        return;
    }
    int path[v];
    int crawl = dest;
    int count = 0;
    path[count++] = crawl;
    while (pred[crawl] != -1) {
        crawl = pred[crawl];
        path[count++] = crawl;
    }
    printf("Shortest path length is: %d\n", dist[dest]);
    printf("Path is:\n");
    for (int i = count - 1; i >= 0; i--)
        printf("%d ", path[i]);
}

int main() {
    int adj[v][v];
    memset(adj, 0, sizeof(adj));
    add_edge(adj, 0, 1);
    add_edge(adj, 0, 3);
    add_edge(adj, 1, 2);
    add_edge(adj, 3, 4);
    add_edge(adj, 3, 7);
    add_edge(adj, 4, 5);
    add_edge(adj, 4, 6);
    add_edge(adj, 4, 7);
    add_edge(adj, 5, 6);
    add_edge(adj, 6, 7);
    int source = 0, dest = 7;
    printShortestDistance(adj, source, dest, v);
    return 0;
}


chatgpt 1
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

#define MAX 100

// A queue node
struct Node {
    int vertex;
    int distance;
};

// Adjacency list representation of a graph
struct Graph {
    int numVertices;
    int* visited;
    int** adjMatrix;
};

// A utility function to initialize the graph
struct Graph* createGraph(int vertices) {
    struct Graph* graph = (struct Graph*) malloc(sizeof(struct Graph));
    graph->numVertices = vertices;
    graph->visited = (int*) malloc(vertices * sizeof(int));
    graph->adjMatrix = (int**) malloc(vertices * sizeof(int*));
    for (int i = 0; i < vertices; i++) {
        graph->visited[i] = 0;
        graph->adjMatrix[i] = (int*) malloc(vertices * sizeof(int));
        for (int j = 0; j < vertices; j++)
            graph->adjMatrix[i][j] = 0;
    }
    return graph;
}

// A utility function to add an edge to the graph
void addEdge(struct Graph* graph, int src, int dest) {
    graph->adjMatrix[src][dest] = 1;
    graph->adjMatrix[dest][src] = 1;
}

// A utility function to print the shortest path
void printPath(int* parent, int j) {
    if (parent[j] == -1)
        return;
    printPath(parent, parent[j]);
    printf("%d ", j);
}

// A utility function to do BFS of graph
// from a given source vertex
void BFS(struct Graph* graph, int src, int dest) {
    struct Node queue[MAX];
    int front = 0, rear = 0;
    int* parent = (int*) malloc(graph->numVertices * sizeof(int));
    for (int i = 0; i < graph->numVertices; i++)
        parent[i] = -1;
    graph->visited[src] = 1;
    queue[rear].vertex = src;
    queue[rear].distance = 0;
    rear++;
    while (front != rear) {
        struct Node node = queue[front++];
        int vertex = node.vertex;
        int distance = node.distance;
        for (int i = 0; i < graph->numVertices; i++) {
            if (graph->adjMatrix[vertex][i] == 1 && !graph->visited[i]) {
                queue[rear].vertex = i;
                queue[rear].distance = distance + 1;
                parent[i] = vertex;
                graph->visited[i] = 1;
                rear++;
            }
        }
    }
    printf("Shortest path length is: %d\n", queue[rear-1].distance);
    printf("Shortest path is: ");
    printPath(parent


chatgpt 2
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#define MAX_VERTICES 100
#define MAX_QUEUE_SIZE 10000

struct Edge {
    int to, next;
};

struct Graph {
    struct Edge edges[MAX_VERTICES];
    int head[MAX_VERTICES];
    int num_vertices;
};

struct Queue {
    int items[MAX_QUEUE_SIZE];
    int front, rear;
};

struct Graph *create_graph(int num_vertices) {
    struct Graph *graph = (struct Graph *)malloc(sizeof(struct Graph));
    graph->num_vertices = num_vertices;
    for (int i = 0; i < num_vertices; i++) {
        graph->head[i] = -1;
    }
    return graph;
}

void add_edge(struct Graph *graph, int from, int to) {
    static int edge_count = 0;
    graph->edges[edge_count].to = to;
    graph->edges[edge_count].next = graph->head[from];
    graph->head[from] = edge_count++;
}

struct Queue *create_queue() {
    struct Queue *queue = (struct Queue *)malloc(sizeof(struct Queue));
    queue->front = -1;
    queue->rear = -1;
    return queue;
}

bool is_empty(struct Queue *queue) {
    return queue->front == -1;
}

void enqueue(struct Queue *queue, int item) {
    queue->items[++queue->rear] = item;
    if (queue->front == -1) {
        queue->front = 0;
    }
}

int dequeue(struct Queue *queue) {
    int item = queue->items[queue->front++];
    if (queue->front > queue->rear) {
        queue->front = queue->rear = -1;
    }
    return item;
}

void find_shortest_path(struct Graph *graph, int source, int destination) {
    int pred[MAX_VERTICES];
    int dist[MAX_VERTICES];
    for (int i = 0; i < graph->num_vertices; i++) {
        pred[i] = -1;
        dist[i] = -1;
    }
    struct Queue *queue = create_queue();
    enqueue(queue, source);
    dist[source] = 0;
    while (!is_empty(queue)) {
        int current = dequeue(queue);
        for (int i = graph->head[current]; i != -1; i = graph->edges[i].next) {
            int neighbor = graph->edges[i].to;
            if (dist[neighbor] == -1) {
                dist[neighbor] = dist[current] + 1;
                pred[neighbor] = current;
                enqueue(queue, neighbor



chatgpt
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#define MAX 100
#define initial 1
#define waiting 2
#define visited 3

int n;      // Number of vertices in the graph
int adj[MAX][MAX]; // Adjacency matrix representation of the graph
int state[MAX];    // Keeps track of the state of each vertex
int pred[MAX];     // Array to store the predecessor of each vertex
int distance[MAX]; // Array to store the distance of each vertex from the source vertex

// Utility function to create an edge between two vertices
void create_edge(int origin, int dest) {
    adj[origin][dest] = 1;
    adj[dest][origin] = 1;
}

// Utility function to perform breadth-first search on the graph
void BFS(int start) {
    int queue[MAX], rear = -1, front = 0;
    int current, i;

    // Initialize all the vertices as not visited
    for (i = 0; i < n; i++) {
        state[i] = initial;
        distance[i] = MAX;
        pred[i] = -1;
    }

    // Start from the source vertex
    queue[++rear] = start;
    state[start] = waiting;
    distance[start] = 0;
    pred[start] = -1;

    // Perform BFS on the graph
    while (rear != front) {
        current = queue[front++];
        state[current] = visited;

        for (i = 0; i < n; i++) {
            if (adj[current][i] == 1 && state[i] == initial) {
                queue[++rear] = i;
                state[i] = waiting;
                distance[i] = distance[current] + 1;
                pred[i] = current;
            }
        }
    }
}

// Utility function to print the shortest path from the source vertex to the destination vertex
void print_path(int dest) {
    int i;
    if (pred[dest] == -1) {
        printf("%d\n", dest);
    } else {
        print_path(pred[dest]);
        printf("%d\n", dest);
    }
}

int main() {
    int origin, dest, start, end;

    // Input the number of vertices in the graph
    printf("Enter the number of vertices: ");
    scanf("%d", &n);

    // Input the edges of the graph
    printf("Enter the edges of the graph (origin dest):\n");
    while (true) {
        scanf("%d %d", &origin, &dest);
        if (origin == 0 && dest == 0) {
            break;
        }
        create_edge(origin, dest);
    }

    // Input the source and destination vertices
    printf("Enter the source and destination vertices: ");
    scanf("%d %d", &start, &end);

    // Perform B

chatgpt sok
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#define MAX_VERTICES 100

int n; // Number of vertices
int e; // Number of edges
int graph[MAX_VERTICES][MAX_VERTICES]; // Adjacency matrix representation of the graph
int start, end; // Start and end vertices
int pred[MAX_VERTICES]; // Array to store the predecessor of each vertex in the path
bool visited[MAX_VERTICES]; // Array to keep track of visited vertices

void bfs(int start) {
    int queue[MAX_VERTICES]; // Queue to keep track of vertices to be processed
    int head = 0, tail = 0; // Head and tail indices of the queue
    int u, v;

    // Enqueue the start vertex and mark it as visited
    queue[tail++] = start;
    visited[start] = true;

    // Process vertices in the queue until it is empty
    while (head != tail) {
        u = queue[head++];

        // Enqueue all unvisited neighbors of u and mark them as visited
        for (v = 0; v < n; v++) {
            if (graph[u][v] == 1 && !visited[v]) {
                queue[tail++] = v;
                pred[v] = u;
                visited[v] = true;

                // If we have reached the end vertex, we are done
                if (v == end) {
                    return;
                }
            }
        }
    }
}

void printPath(int v) {
    if (v == start) {
        printf("%d ", start);
        return;
    }
    printPath(pred[v]);
    printf("%d ", v);
}

int main() {
    int i, j, u, v;

    // Input the number of vertices and edges
    scanf("%d%d", &n, &e);

    // Input the edges
    for (i = 0; i < e; i++) {
        scanf("%d%d", &u, &v);
        graph[u][v] = graph[v][u] = 1;
    }

    // Input the start and end vertices
    scanf("%d%d", &start, &end);

    // Run BFS to find the shortest path
    bfs(start);

    // Print the path
    printPath(end);

    return 0;
}


chatgpt megtobb
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#define MAX_VERTICES 100

struct Queue {
    int front, rear;
    int items[MAX_VERTICES];
};

struct Graph {
    int numVertices;
    int adjacencyMatrix[MAX_VERTICES][MAX_VERTICES];
};

struct Queue* createQueue() {
    struct Queue* q = malloc(sizeof(struct Queue));
    q->front = -1;
    q->rear = -1;
    return q;
}

bool isQueueEmpty(struct Queue* q) {
    return q->front == -1;
}

void enqueue(struct Queue* q, int value) {
    q->items[++q->rear] = value;
    if (q->front == -1) {
        q->front = 0;
    }
}

int dequeue(struct Queue* q) {
    int item = q->items[q->front++];
    if (q->front > q->rear) {
        q->front = q->rear = -1;
    }
    return item;
}

void addEdge(struct Graph* graph, int src, int dest) {
    graph->adjacencyMatrix[src][dest] = 1;
    graph->adjacencyMatrix[dest][src] = 1;
}

void printShortestPath(int parent[], int dest) {
    if (parent[dest] == -1) {
        return;
    }
    printShortestPath(parent, parent[dest]);
    printf("%d ", dest);
}

void bfs(struct Graph* graph, int start, int dest) {
    int parent[MAX_VERTICES];
    bool visited[MAX_VERTICES];

    for (int i = 0; i < graph->numVertices; i++) {
        visited[i] = false;
        parent[i] = -1;
    }

    struct Queue* q = createQueue();
    enqueue(q, start);
    visited[start] = true;

    while (!isQueueEmpty(q)) {
        int current = dequeue(q);
        for (int i = 0; i < graph->numVertices; i++) {
            if (graph->adjacencyMatrix[current][i] == 1 && !visited[i]) {
                enqueue(q, i);
                visited[i] = true;
                parent[i] = current;
                if (i == dest) {
                    printShortestPath(parent, dest);
                    return;
                }
            }
        }
    }
}

int main() {
    struct Graph* graph = malloc(sizeof(struct Graph));
    graph->numVertices = 8;

    addEdge(graph, 0, 1);
    addEdge(graph, 0, 3);
    addEdge(graph, 1, 2);
    addEdge(graph, 3, 4);
    addEdge(


#include <stdio.h>
#include <stdlib.h>

#define MAX_VERTICES 100

int adjacency_matrix[MAX_VERTICES][MAX_VERTICES];
int parent[MAX_VERTICES];
int vertices;

void add_edge(int source, int destination) {
    adjacency_matrix[source][destination] = 1;
    adjacency_matrix[destination][source] = 1;
}

void bfs(int start, int end) {
    int queue[MAX_VERTICES];
    int front = 0, rear = 0;
    int current, i;
    int visited[MAX_VERTICES];

    for (i = 0; i < vertices; i++) {
        visited[i] = 0;
        parent[i] = -1;
    }

    queue[rear++] = start;
    visited[start] = 1;

    while (front != rear) {
        current = queue[front++];

        for (i = 0; i < vertices; i++) {
            if (adjacency_matrix[current][i] == 1 && !visited[i]) {
                queue[rear++] = i;
                parent[i] = current;
                visited[i] = 1;

                if (i == end) {
                    return;
                }
            }
        }
    }
}

void print_path(int end) {
    if (parent[end] == -1) {
        return;
    }

    print_path(parent[end]);
    printf("%d ", end);
}

int main() {
    int i, start, end;

    printf("Enter the number of vertices: ");
    scanf("%d", &vertices);

    printf("Enter the edges (source destination):\n");
    while (1) {
        int source, destination;
        scanf("%d%d", &source, &destination);
        if (source == -1 && destination == -1) {
            break;
        }
        add_edge(source, destination);
    }

    printf("Enter the start vertex: ");
    scanf("%d", &start);

    printf("Enter the end vertex: ");
    scanf("%d", &end);

    bfs(start, end);

    printf("The shortest path is: ");
    print_path(end);
    printf("\n");

    return 0;
}